- [دستور pwd (Print Working Directory)](#دستور-pwd-print-working-directory)
- [دستور ls (List)](#دستور-ls-list)
- [دستور cd (Change Directory)](#دستور-cd-change-directory)
- [دستور mkdir (Make Directory)](#دستور-mkdir-make-directory)
- [دستور touch](#دستور-touch)
- [دستور rmdir (Remove Directory)](#دستور-rmdir-remove-directory)
- [دستور man (Manual)](#دستور-man-manual)
- [دستور cp (Copy)](#دستور-cp-copy)
- [دستور mv (Move)](#دستور-mv-move)
- [دستور rm (Remove)](#دستور-rm-remove)
- [دستورات مشاهده محتوا: cat و less](#دستورات-مشاهده-محتوا-cat-و-less)
- [دستور chmod (Change Mode)](#دستور-chmod-change-mode)
- [دستورات head و tail](#دستورات-head-و-tail)
- [دستور sort](#دستور-sort)
- [دستور nl (Number Lines)](#دستور-nl-number-lines)
- [دستور wc (Word Count)](#دستور-wc-word-count)
- [دستور sed (Stream Editor)](#دستور-sed-stream-editor)
- [دستور uniq (Unique)](#دستور-uniq-unique)
- [دستور tac (Reverse Cat)](#دستور-tac-reverse-cat)
- [دستور ps (Process Status)](#دستور-ps-process-status)
- [دستور kill](#دستور-kill)
- [جستجو و فیلتر پیشرفته: grep، egrep و regex](#جستجو-و-فیلتر-پیشرفته-grep-egrep-و-regex)
- [دستور history](#دستور-history-تاریخچه-فرمان‌ها)
- [دستورات Redirection و Pipe](#دستورات-تغییر-مسیر-redirection-و-پایپ-pipe)
- [تفاوت های Wildcards vs Regex](#تفاوت-حیاتی-wildcards-در-برابر-regex)



# فصل اول: آموزش دستورات خط فرمان (Terminal Commands)

## دستور `pwd` (Print Working Directory)

### مقدمه و هدف
در محیط‌های گرافیکی (GUI)، شما با نگاه کردن به بالای پنجره‌ی فایل‌منیجر (File Manager) می‌دانید در چه پوشه‌ای هستید. اما در محیط متنی (CLI) ترمینال، شما همواره در یک مسیر خاص قرار دارید که به آن "دایرکتوری کاری فعلی" (Current Working Directory) گفته می‌شود. بدون دانستن اینکه کجا هستید، اجرای دستوراتی مثل حذف یا ایجاد فایل می‌تواند خطرناک باشد. دستور `pwd` دقیقاً به شما می‌گوید در کجای ساختار درختی فایل‌سیستم لینوکس ایستاده‌اید. نام این دستور مخفف **P**rint **W**orking **D**irectory است.

### سینتکس (Syntax)
ساختار کلی این دستور بسیار ساده است و معمولاً بدون هیچ آرگومانی استفاده می‌شود:

```bash
pwd [OPTION]...
```

### توضیحات فنی
وقتی ترمینال باز می‌شود، معمولاً در دایرکتوری خانگی کاربر (`/home/username` یا `~`) قرار دارید. `pwd` مسیر کامل (Absolute Path) را از ریشه (Root یا `/`) تا مکانی که الان هستید، چاپ می‌کند.

### سوئیچ‌های کاربردی (Options)
اگرچه `pwd` اغلب به تنهایی استفاده می‌شود، اما دو سوئیچ مهم دارد که برای درک لینک‌های نمادین (Symbolic Links) حیاتی هستند:

1.  **`-L` (Logical):** (پیش‌فرض) اگر مسیری که در آن هستید یک لینک نمادین (Symlink) باشد، همان مسیر لینک را نمایش می‌دهد (مسیری که کاربر منطقاً فکر می‌کند در آن است).
2.  **`-P` (Physical):** اگر در یک لینک نمادین باشید، مسیر واقعی و فیزیکی دایرکتوری اصلی را نشان می‌دهد (لینک را حل یا resolve می‌کند).

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: استفاده ساده برای یافتن مکان فعلی**
در این مثال، کاربر می‌خواهد بداند دقیقاً در کجای سیستم فایل قرار دارد.

```bash
user@linux-machine:~$ pwd
/home/student/projects
```
*تفسیر:* شما در پوشه `projects` هستید که زیرمجموعه `student` و آن هم زیرمجموعه `home` است.

**مثال ۲: تفاوت سوئیچ `-L` و `-P` (مهم برای مهندسین کامپیوتر)**
فرض کنید یک لینک (Shortcut) به نام `code` در پوشه خانه دارید که به مسیر `/var/www/html` اشاره می‌کند. شما با دستور `cd code` وارد آن شده‌اید.

حالت منطقی (Logical):
```bash
user@linux-machine:~/code$ pwd -L
/home/student/code
```
*تفسیر:* لینوکس به شما مسیری را نشان می‌دهد که از طریق آن وارد شدید (لینک).

حالت فیزیکی (Physical):
```bash
user@linux-machine:~/code$ pwd -P
/var/www/html
```
*تفسیر:* لینوکس به شما مکان واقعی فایل‌ها روی دیسک را نشان می‌دهد.

### نکات تکمیلی
*   خروجی `pwd` همیشه یک **مسیر مطلق** (Absolute Path) است، یعنی همیشه با `/` شروع می‌شود.
*   در اسکریپت‌نویسی Bash، بسیار رایج است که خروجی این دستور را داخل یک متغیر ذخیره کنند تا اسکریپت بداند در کجا در حال اجراست:
    ```bash
    CURRENT_DIR=$(pwd)
    ```

---
بسیار عالی. دستور بعدی، پرکاربردترین دستور لینوکس برای "مشاهده محتوا" است. از آنجایی که چندین حالت مختلف از این دستور را درخواست کردید، همه را در قالب یک بخش جامع برای دستور `ls` تدوین می‌کنم تا پیوستگی مطالب حفظ شود.

---

## دستور `ls` (List)

### مقدمه و هدف
در سیستم‌عامل لینوکس، برخلاف ویندوز که محتوای پوشه‌ها را به صورت آیکون در اکسپلورر می‌بینید، در ترمینال هیچ چیزی به صورت پیش‌فرض نمایش داده نمی‌شود. دستور `ls` (مخفف **L**i**s**t) چشمان شما در ترمینال است. هدف اصلی آن نمایش لیست فایل‌ها و دایرکتوری‌های موجود در مسیر جاری (یا مسیری که شما تعیین می‌کنید) است. بدون `ls`، شما در ترمینال کور هستید.

### سینتکس (Syntax)
```bash
ls [OPTION]... [FILE]...
```

### توضیحات پارامترها و سوئیچ‌های مهم
دستور `ls` به تنهایی فقط نام فایل‌ها را نشان می‌دهد، اما قدرت واقعی آن در سوئیچ‌هایش نهفته است:

1.  **`-a` (All):** در لینوکس، فایل‌هایی که نامشان با نقطه (`.`) شروع شود، مخفی (Hidden) هستند (مانند فایل‌های پیکربندی مثل `.bashrc`). دستور `ls` عادی این‌ها را نشان نمی‌دهد. سوئیچ `-a` همه فایل‌ها، حتی مخفی‌ها را نمایش می‌دهد.
2.  **`-l` (Long Listing Format):** این سوئیچ حیاتی‌ترین حالت نمایش برای مهندسین کامپیوتر است. به جای فقط نام فایل، جزئیات کاملی شامل مجوزها (Permissions)، تعداد لینک‌ها، مالک فایل (Owner)، گروه (Group)، حجم و تاریخ آخرین تغییر را نمایش می‌دهد.
3.  **`-d` (Directory):** به صورت پیش‌فرض، اگر `ls` را روی یک دایرکتوری اجرا کنید، محتویات *داخل* آن را نشان می‌دهد. اگر بخواهید اطلاعات خودِ آن دایرکتوری (و نه محتوایش) را ببینید، باید از `-d` استفاده کنید (معمولاً در ترکیب با `-l` استفاده می‌شود: `-ld`).

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: استفاده ساده (`ls`)**
نمایش ساده فایل‌های غیرمخفی در دایرکتوری جاری.

```bash
user@linux-machine:~$ ls
Desktop  Documents  Downloads  music.mp3  project.c
```

**مثال ۲: نمایش فایل‌های مخفی (`ls -a`)**
مشاهده فایل‌های تنظیمات که معمولاً پنهان هستند. توجه کنید که `.` (دایرکتوری جاری) و `..` (دایرکتوری پدر) نیز نمایش داده می‌شوند.

```bash
user@linux-machine:~$ ls -a
.  ..  .bash_history  .bashrc  Desktop  Documents  .ssh
```

**مثال ۳: نمایش با جزئیات کامل (`ls -l`)**
تحلیل خروجی این دستور برای دانشجوی کامپیوتر الزامی است.

```bash
user@linux-machine:~$ ls -l
total 12
drwxr-xr-x 2 student users 4096 Nov 30 10:00 Documents
-rw-r--r-- 1 student users  512 Nov 29 14:30 project.c
-rwxr-xr-x 1 student users 8192 Nov 29 14:35 app.exe
```
*تحلیل خروجی:*
*   ستون اول (`drwxr-xr-x`): نوع فایل و مجوزها (d اول یعنی دایرکتوری، `-` یعنی فایل).
*   ستون سوم و چهارم (`student users`): مالک فایل و گروه مربوطه.
*   ستون پنجم (`4096`): حجم فایل به بایت.

**مثال ۴: نمایش اطلاعات خود دایرکتوری (`ls -ld`)**
فرض کنید می‌خواهید مجوزهای پوشه `/etc` را چک کنید، نه اینکه هزاران فایل داخل آن را لیست کنید.

*حالت اشتباه (بدون `-d`):*
```bash
user@linux-machine:~$ ls -l /etc
# (هزاران خط خروجی نمایش داده می‌شود که محتویات داخل etc است)
```

*حالت صحیح (با `-d`):*
```bash
user@linux-machine:~$ ls -ld /etc
drwxr-xr-x 128 root root 12288 Nov 30 09:15 /etc
```
*تفسیر:* این دستور فقط یک خط برمی‌گرداند که اطلاعات خودِ پوشه `/etc` است.

### نکات تکمیلی
*   **Human Readable:** سوئیچ `-h` را می‌توان با `-l` ترکیب کرد (`ls -lh`) تا حجم فایل‌ها را به جای بایت، به صورت KB, MB یا GB نمایش دهد که خوانایی بیشتری دارد.
*   **ترکیب سوئیچ‌ها:** در لینوکس می‌توان سوئیچ‌ها را چسباند. `ls -la` همان کار `ls -l -a` را انجام می‌دهد (نمایش لیست کامل فایل‌های مخفی و غیرمخفی).
*   **رنگ‌بندی:** در اکثر توزیع‌های مدرن، خروجی `ls` رنگی است (مثلاً دایرکتوری‌ها آبی، فایل‌های اجرایی سبز). این قابلیت معمولاً با `alias` در فایل `.bashrc` تنظیم شده است (`ls --color=auto`).

---

## دستور `cd` (Change Directory)

### مقدمه و هدف
همانطور که در ویندوز روی پوشه‌ها دابل‌کلیک می‌کنید تا واردشان شوید، در ترمینال از دستور `cd` برای جابجایی بین دایرکتوری‌ها استفاده می‌کنید. این دستور "دایرکتوری کاری" (Working Directory) شما را تغییر می‌دهد.

### سینتکس
```bash
cd [DIRECTORY]
```

### توضیحات و میانبرهای مهم
*   **مسیر نسبی (Relative):** آدرس‌دهی نسبت به جایی که الان هستید (مثلاً `cd Documents`).
*   **مسیر مطلق (Absolute):** آدرس‌دهی کامل از ریشه (مثلاً `cd /home/user/Documents`).
*   **`cd ..`**: حرکت به دایرکتوری والد (یک مرحله عقب رفتن).
*   **`cd` (خالی) یا `cd ~`**: بازگشت سریع به دایرکتوری خانگی (Home).
*   **`cd -`**: بازگشت به آخرین دایرکتوری که قبل از این در آن بودید (مثل دکمه Back کنترل تلویزیون).

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: ورود به یک پوشه و بازگشت به عقب**
```bash
user@linux-machine:~$ cd Documents/Projects
user@linux-machine:~/Documents/Projects$ cd ..
user@linux-machine:~/Documents$
```

**مثال ۲: پرش سریع به خانه از هر جایی**
```bash
user@linux-machine:/var/www/html$ cd
user@linux-machine:~$
```

---

## دستور `mkdir` (Make Directory)

### مقدمه و هدف
برای سازماندهی فایل‌ها نیاز به ایجاد پوشه (Folder/Directory) دارید. `mkdir` دقیقاً این کار را انجام می‌دهد.

### سینتکس
```bash
mkdir [OPTION] DIRECTORY...
```

### توضیحات پارامترها
*   **`-p` (Parents):** این سوئیچ بسیار مهم است. اگر بخواهید یک مسیر تودرتو بسازید (مثلاً پوشه `c` داخل `b` داخل `a`) و پوشه‌های والد (`a` و `b`) وجود نداشته باشند، `mkdir` عادی خطا می‌دهد. اما `mkdir -p` پوشه‌های والدِ غایب را هم می‌سازد.

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: ساخت دایرکتوری ساده**
```bash
user@linux-machine:~$ mkdir myfolder
```

**مثال ۲: ساخت ساختار درختی (Nested Directories)**
ساختن پوشه `2025`، داخلش `images` و داخلش `holiday` به صورت یکجا.
```bash
user@linux-machine:~$ mkdir -p 2025/images/holiday
```

---

## دستور `touch`

### مقدمه و هدف
دستور `touch` دو کاربرد دارد:
1.  **کاربرد اصلی (تاریخچه):** به‌روزرسانی Timestamp (زمان دسترسی و تغییر) یک فایل بدون تغییر محتوای آن.
2.  **کاربرد رایج (امروزی):** ایجاد سریع یک فایل خالی. اگر نام فایلی را به `touch` بدهید که وجود ندارد، آن را می‌سازد.

### سینتکس
```bash
touch [OPTION]... FILE...
```

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: ایجاد فایل جدید**
```bash
user@linux-machine:~$ touch program.py
user@linux-machine:~$ ls -l program.py
-rw-r--r-- 1 user user 0 Nov 30 10:15 program.py
```
*نکته:* حجم فایل 0 است.

**مثال ۲: ایجاد چندین فایل همزمان**
```bash
user@linux-machine:~$ touch file1.txt file2.txt file3.txt
```

---

## دستور `rmdir` (Remove Directory)

### مقدمه و هدف
این دستور برای حذف دایرکتوری‌ها استفاده می‌شود، اما یک شرط امنیتی مهم دارد: **دایرکتوری باید حتماً خالی باشد.** اگر پوشه‌ای حاوی فایل باشد، `rmdir` آن را پاک نمی‌کند. این طراحی برای جلوگیری از حذف ناخواسته اطلاعات است.

### سینتکس
```bash
rmdir [OPTION] DIRECTORY...
```

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: حذف یک پوشه خالی**
```bash
user@linux-machine:~$ rmdir EmptyFolder
```

**مثال ۲: تلاش برای حذف پوشه پر (خطا)**
```bash
user@linux-machine:~$ rmdir MyProject
rmdir: failed to remove 'MyProject': Directory not empty
```
*نکته:* برای حذف پوشه‌های پر، در ادامه دستور `rm` را یاد خواهیم گرفت.

### خلاصه بخش
*   `cd`: جابجایی (حرکت).
*   `mkdir`: ساختن پوشه.
*   `touch`: ساختن فایل خالی.
*   `rmdir`: حذف پوشه (فقط اگر خالی باشد).

---

## دستور `man` (Manual)

### مقدمه و هدف
لینوکس سیستم‌عاملی است که مستندات آن همراه خودش ارائه می‌شود. تقریباً هر دستور، فایل پیکربندی یا تابع سیستمی در لینوکس، یک صفحه راهنما دارد که به آن **Man Page** می‌گویند. دستور `man` رابطی است برای خواندن این صفحات. هر زمان که طرز کار دستوری را فراموش کردید یا نیاز داشتید سوئیچ‌های پیشرفته آن را بشناسید، `man` بهترین مرجع شماست (حتی معتبرتر از گوگل، چون دقیقاً با نسخه نرم‌افزار نصب شده روی سیستم شما منطبق است).

### سینتکس (Syntax)
```bash
man [OPTION] [COMMAND_NAME]
```

### ساختار صفحات Man
وقتی وارد صفحه راهنمای یک دستور می‌شوید (مثلاً `man ls`)، اطلاعات به بخش‌های استانداردی تقسیم شده‌اند:
1.  **NAME:** نام دستور و توضیح یک‌خطی.
2.  **SYNOPSIS:** الگوی نحوی دستور (چگونه باید تایپ شود).
3.  **DESCRIPTION:** توضیحات کامل عملکرد.
4.  **OPTIONS:** لیست تمام سوئیچ‌ها و کارهایی که انجام می‌دهند.
5.  **EXAMPLES:** مثال‌های نحوه استفاده (گاهی اوقات).
6.  **SEE ALSO:** دستورات مرتبط دیگر.

### نحوه کنترل در محیط Man
وقتی صفحه راهنما باز می‌شود، شما وارد یک محیط خواندن متن می‌شوید (معمولاً برنامه `less`). کلیدهای کنترلی مهم عبارتند از:
*   **Arrow Keys (↑ ↓):** اسکرول خط به خط.
*   **Space:** رفتن به صفحه بعد.
*   **b:** برگشتن به صفحه قبل (Back).
*   **`/keyword`:** جستجو برای کلمه `keyword` (با زدن `n` به نتیجه بعدی می‌روید).
*   **q:** خروج از راهنما (Quit).

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: مشاهده راهنمای دستور ls**
```bash
user@linux-machine:~$ man ls
```
*(خروجی زیر نمایش داده می‌شود و ترمینال وارد حالت تمام‌صفحه می‌شود)*
```text
LS(1)                            User Commands                           LS(1)

NAME
       ls - list directory contents

SYNOPSIS
       ls [OPTION]... [FILE]...

DESCRIPTION
       List information about the FILEs (the current directory by default).
       Sort entries alphabetically if none of -cftuvSUX nor --sort is speci‐
       fied.
...
(Press q to quit)
```

**مثال ۲: جستجو در توضیحات دستورات (apropos)**
گاهی نام دقیق دستور را نمی‌دانید، اما می‌دانید چه کاری می‌خواهید انجام دهید (مثلاً کپی کردن). سوئیچ `-k` کلیدواژه‌ها را در تمام صفحات راهنما جستجو می‌کند.

```bash
user@linux-machine:~$ man -k "copy files"
cp (1)               - copy files and directories
install (1)          - copy files and set attributes
gio-copy (1)         - Copy files
```
*تفسیر:* سیستم لیستی از دستوراتی که در توضیحاتشان عبارت "copy files" وجود دارد را نشان داد. اینجا می‌فهمیم دستور `cp` مناسب کار ماست.

### نکات تکمیلی (شماره بخش‌ها)
صفحات Man به 8 بخش (Section) تقسیم می‌شوند. مثلاً بخش 1 مربوط به دستورات کاربری (`ls`, `cd`) و بخش 3 مربوط به توابع کتابخانه برنامه‌نویسی C (`printf`) است.
گاهی یک نام در چند بخش وجود دارد (مثلاً `printf` هم دستور ترمینال است و هم تابع C).
برای دیدن بخش خاص:
```bash
man 3 printf  # راهنمای تابع C
man 1 printf  # راهنمای دستور ترمینال
```

---


## دستور `cp` (Copy)

### مقدمه و هدف
همانند عملیات Copy-Paste در ویندوز، در لینوکس نیز نیاز داریم فایل‌ها را تکثیر کنیم یا از آنها نسخه پشتیبان (Backup) بگیریم. دستور `cp` (مخفف **C**o**p**y) وظیفه کپی کردن فایل‌ها و دایرکتوری‌ها از یک مبدا (Source) به یک مقصد (Destination) را بر عهده دارد.

### سینتکس (Syntax)
```bash
cp [OPTION]... SOURCE DESTINATION
cp [OPTION]... SOURCE... DIRECTORY
```
*   حالت اول: کپی یک فایل به نام یا مسیری جدید.
*   حالت دوم: کپی چندین فایل به داخل یک دایرکتوری.

### توضیحات پارامترها و سوئیچ‌های مهم
*   **`-r` یا `-R` (Recursive):** این مهم‌ترین سوئیچ برای کپی کردن **پوشه‌ها (دایرکتوری‌ها)** است. به صورت پیش‌فرض `cp` نمی‌تواند یک پوشه را کپی کند چون پوشه حاوی فایل‌های دیگر است. این سوئیچ به دستور می‌گوید: "خودِ پوشه و تمام محتویات داخلش را به صورت تودرتو کپی کن".
*   **`-i` (Interactive):** قبل از اینکه فایلی در مقصد را بازنویسی (Overwrite) کند، از شما تایید می‌گیرد. (بسیار مفید برای جلوگیری از پاک شدن ناخواسته فایل‌های هم‌نام).
*   **`-v` (Verbose):** عملیات کپی را با جزئیات نشان می‌دهد (می‌گوید چه فایلی کجا کپی شد).

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: کپی ساده یک فایل (ایجاد بک‌آپ)**
می‌خواهیم از `report.txt` یک کپی به نام `report.bak` بگیریم.

```bash
user@linux-machine:~$ cp report.txt report.bak
```

**مثال ۲: کپی کردن فایل به دایرکتوری دیگر**
کپی کردن فایل `image.png` به داخل پوشه `Pictures`.

```bash
user@linux-machine:~$ cp image.png Pictures/
```

**مثال ۳: کپی دایرکتوری (بسیار مهم)**
تلاش برای کپی پوشه بدون سوئیچ `-r` منجر به خطا می‌شود:

```bash
user@linux-machine:~$ cp MyFolder /tmp
cp: -r not specified; omitting directory 'MyFolder'
```

روش صحیح با استفاده از `-r`:
```bash
user@linux-machine:~$ cp -r MyFolder /tmp
```
*تفسیر:* کل پوشه `MyFolder` با تمام محتویاتش در `/tmp` کپی شد.

**مثال ۴: کپی چند فایل به یک پوشه**
```bash
user@linux-machine:~$ cp file1.c file2.h /home/student/project/
```

### نکات تکمیلی
*   اگر در مقصد، فایلی هم‌نام با مبدا وجود داشته باشد، `cp` بدون پرسش آن را **بازنویسی (Overwrite)** می‌کند و محتوای قبلی از بین می‌رود (مگر اینکه از `-i` استفاده کنید).
*   اگر می‌خواهید ویژگی‌های فایل (مثل تاریخ ایجاد، مالک و دسترسی‌ها) هنگام کپی حفظ شود، از سوئیچ `-p` (Preserve) استفاده کنید.

---

## دستور `mv` (Move)

### مقدمه و هدف
دستور `mv` (مخفف **M**o**v**e) دو وظیفه اصلی دارد که در نگاه اول متفاوت به نظر می‌رسند اما از نظر سیستم‌عامل یکسانند:
1.  **جابجایی فایل/پوشه:** انتقال فایل از یک مسیر به مسیر دیگر (مانند Cut-Paste).
2.  **تغییر نام (Rename):** اگر فایلی را در همان مسیر فعلی به نام جدیدی "جابجا" کنید، در واقع نامش را تغییر داده‌اید.

برخلاف `cp`، دستور `mv` نسخه اصلی را حذف می‌کند و فقط نسخه جدید را در مقصد نگه می‌دارد.

### سینتکس (Syntax)
```bash
mv [OPTION]... SOURCE DESTINATION
mv [OPTION]... SOURCE... DIRECTORY
```

### توضیحات پارامترها و سوئیچ‌های مهم
*   **`-i` (Interactive):** حیاتی‌ترین سوئیچ ایمنی. اگر در مقصد فایلی هم‌نام وجود داشته باشد، `mv` به صورت پیش‌فرض آن را بی‌صدا نابود (Overwrite) می‌کند. با `-i` سیستم قبل از جایگزینی از شما اجازه می‌گیرد.
*   **`-u` (Update):** فقط در صورتی فایل را جابجا می‌کند که فایل مبدا جدیدتر از فایل موجود در مقصد باشد (یا فایل در مقصد نباشد).
*   **`-v` (Verbose):** گزارش کار را چاپ می‌کند (چه چیزی به کجا رفت).

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: تغییر نام فایل (Rename)**
در لینوکس دستور جداگانه‌ای برای Rename نداریم. برای تغییر نام `old.txt` به `new.txt` از `mv` استفاده می‌کنیم.

```bash
user@linux-machine:~$ mv old.txt new.txt
```
*تفسیر:* فایل `old.txt` برداشته شد و با برچسب `new.txt` در همین‌جا قرار گرفت.

**مثال ۲: جابجایی فایل به پوشه دیگر (Cut & Paste)**
انتقال `music.mp3` به پوشه `Music`.

```bash
user@linux-machine:~$ mv music.mp3 Music/
```

**مثال ۳: جابجایی و تغییر نام همزمان**
می‌خواهیم `script.py` را به پوشه `bin` ببریم و همزمان نامش را به `main.py` تغییر دهیم.

```bash
user@linux-machine:~$ mv script.py bin/main.py
```

**مثال ۴: جلوگیری از فاجعه (استفاده از `-i`)**
فرض کنید در پوشه مقصد فایلی به نام `config` دارید و ناخواسته می‌خواهید فایلی دیگر را روی آن `mv` کنید.

```bash
user@linux-machine:~$ mv -i config_v2 config
mv: overwrite 'config'? n
```
*تفسیر:* سیستم پرسید آیا بازنویسی کنم؟ و شما با زدن `n` (خیر) عملیات را لغو کردید.

### نکات تکمیلی
*   دستور `mv` برای دایرکتوری‌ها نیازی به سوئیچ `-r` (Recursive) ندارد. جابجایی پوشه ذاتاً شامل تمام محتویاتش است.
*   عملیات `mv` در داخل یک پارتیشن (File System) بسیار سریع است چون فقط آدرس‌دهی فایل تغییر می‌کند و دیتایی کپی نمی‌شود. اما اگر بین دو پارتیشن مختلف (مثلاً از هارد به فلش) `mv` کنید، عملاً یک `cp` و سپس `rm` انجام می‌شود که زمان‌بر است.

---

## دستور `rm` (Remove)

### مقدمه و هدف
در ویندوز وقتی فایلی را حذف می‌کنید، به سطل بازیافت (Recycle Bin) می‌رود و قابل بازگشت است. در خط فرمان لینوکس، **Recycle Bin وجود ندارد**. وقتی با دستور `rm` فایلی را پاک می‌کنید، برای همیشه از بین می‌رود (مگر با ابزارهای بسیار پیشرفته بازیابی اطلاعات). دستور `rm` (مخفف **R**e**m**ove) برای حذف فایل‌ها و دایرکتوری‌ها استفاده می‌شود.

### سینتکس (Syntax)
```bash
rm [OPTION]... FILE...
```

### توضیحات پارامترها و سوئیچ‌های مهم
*   **`-r` یا `-R` (Recursive):** برای حذف **دایرکتوری‌ها** و تمام محتویات داخلشان الزامی است. بدون این سوئیچ، `rm` فقط می‌تواند فایل‌ها را پاک کند.
*   **`-f` (Force):** حالت "زورکی" یا اجباری. بدون هیچ سوالی فایل‌ها را پاک می‌کند، حتی اگر فایل‌ها محافظت‌شده باشند یا وجود نداشته باشند (خطا نمی‌دهد).
*   **`-i` (Interactive):** "فرشته نجات". برای هر فایلی که می‌خواهد پاک شود، از شما تایید می‌گیرد.
*   **`-v` (Verbose):** نمایش می‌دهد چه فایل‌هایی در حال پاک شدن هستند.

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: حذف ساده فایل**
```bash
user@linux-machine:~$ rm garbage.txt
```

**مثال ۲: حذف تعاملی (توصیه شده برای مبتدیان)**
حذف فایل‌های مهم با تاییدیه.

```bash
user@linux-machine:~$ rm -i thesis.pdf
rm: remove regular file 'thesis.pdf'? y
```

**مثال ۳: حذف دایرکتوری و محتویاتش**
تلاش برای حذف دایرکتوری بدون `-r` با شکست مواجه می‌شود.

```bash
user@linux-machine:~$ rm project_folder
rm: cannot remove 'project_folder': Is a directory
```

روش صحیح:
```bash
user@linux-machine:~$ rm -r project_folder
```

**مثال ۴: ترکیب خطرناک (`rm -rf`)**
این دستور برای حذف یک پوشه پر، بدون هیچ سوال و جوابی استفاده می‌شود. اغلب برای پاک کردن پروژه‌های بزرگ استفاده می‌شود.

```bash
user@linux-machine:~$ rm -rf build_directory/
```
*هشدار:* اگر این دستور را اشتباه بزنید (مثلاً `rm -rf /`) کل سیستم‌عامل شما پاک خواهد شد! همیشه قبل از زدن اینتر، مسیر را دو بار چک کنید.

### نکات تکمیلی
*   **تفاوت `rmdir` و `rm -r`:** دستور `rmdir` فقط پوشه‌های کاملاً خالی را پاک می‌کند (امن است). دستور `rm -r` پوشه را با هر چه داخلش باشد (فایل، پوشه دیگر) نابود می‌کند.
*   در محیط‌های شرکتی و سرورهای حساس، گاهی `alias rm='rm -i'` در فایل تنظمیات کاربر قرار داده می‌شود تا همیشه قبل از حذف سوال پرسیده شود.

---

## دستورات مشاهده محتوا: `cat` و `less`

### ۱. دستور `cat` (Concatenate)

#### مقدمه و هدف
بسیاری از کاربران مبتدی فکر می‌کنند `cat` مخفف "Cat" (گربه) است! اما در واقع مخفف **ConCATenate** به معنای "به هم چسباندن" یا "الحاق" است.
هدف اصلی این دستور، چسباندن محتویات چند فایل به هم و نمایش آن‌ها در خروجی است. اما اگر فقط نام یک فایل را به آن بدهید، محتویات همان فایل را کامل در ترمینال چاپ می‌کند.
**مشکل `cat`:** اگر فایل طولانی باشد (مثل یک کتاب هزار صفحه‌ای)، `cat` تمام آن را در کسری از ثانیه چاپ می‌کند و شما فقط خطوط آخر را می‌بینید (چون بقیه اسکرول شده و رد شده‌اند).

#### سینتکس (Syntax)
```bash
cat [OPTION]... [FILE]...
```

#### سوئیچ‌های مهم
*   **`-n` (Number):** شماره خطوط را در کنار هر خط چاپ می‌کند. (بسیار مفید برای برنامه‌نویسان جهت دیباگ کردن کد).
*   **`-b`:** شبیه `-n` است اما خطوط خالی را شماره‌گذاری نمی‌کند.

#### مثال‌های عملی (Terminal Simulation)

**مثال ۱: مشاهده محتویات یک فایل کوتاه**
```bash
user@linux-machine:~$ cat hello.py
print("Hello World")
x = 5 + 6
print(x)
```

**مثال ۲: مشاهده با شماره خط (مناسب برای کد)**
```bash
user@linux-machine:~$ cat -n settings.conf
     1  # Network Settings
     2  IP=192.168.1.10
     3  PORT=8080
     4
     5  # User Settings
     6  USER=admin
```

**مثال ۳: استفاده واقعی از Concatenate (چسباندن دو فایل)**
فرض کنید یک فایل `part1.txt` و یک فایل `part2.txt` دارید و می‌خواهید آن‌ها را پشت سر هم ببینید.

```bash
user@linux-machine:~$ cat part1.txt part2.txt
This is text from file 1.
This is text from file 2 appended right after.
```

---

### ۲. دستور `less`

#### مقدمه و هدف
وقتی فایل‌ها طولانی هستند (مثل فایل‌های لاگ سیستم یا سورس‌کدهای بزرگ)، دستور `cat` کارایی ندارد. دستور `less` محتویات فایل را **صفحه به صفحه** (Page by Page) نمایش می‌دهد.
*نکته تاریخی:* در قدیم دستوری به نام `more` وجود داشت که فقط اجازه می‌داد به پایین بروید. `less` نسخه پیشرفته‌تر آن است که اجازه می‌دهد به بالا و پایین بروید. شعار یونیکسی معروف: *"Less is More"* (اشاره به اینکه `less` قابلیت‌های بیشتری از `more` دارد).

#### سینتکس (Syntax)
```bash
less filename
```

#### کلیدهای کنترلی (Navigation)
وقتی وارد محیط `less` می‌شوید، خط فرمان ناپدید می‌شود. برای کار در این محیط باید کلیدهای زیر را بشناسید (مشابه دستور `man`):

*   **`Space` یا `Page Down`:** رفتن به صفحه بعدی.
*   **`b` یا `Page Up`:** برگشتن به صفحه قبلی.
*   **`Enter` یا `Arrow Down`:** رفتن فقط یک خط به پایین.
*   **`g` (کوچک):** رفتن به ابتدای فایل.
*   **`G` (بزرگ):** رفتن به انتهای فایل (بسیار کاربردی برای چک کردن آخرین خطاهای لاگ).
*   **`/word`:** جستجو به دنبال کلمه "word". (با `n` به نتیجه بعدی بروید).
*   **`q`:** خروج از محیط `less` و بازگشت به ترمینال.

#### مثال‌های عملی (Terminal Simulation)

**مثال ۱: باز کردن یک فایل لاگ طولانی**
```bash
user@linux-machine:~$ less /var/log/syslog
```
*(در این حالت ترمینال پاک می‌شود و محتویات فایل نمایش داده می‌شود. کاربر با کلیدهای جهت‌نما متن را می‌خواند و سپس `q` را می‌زند).*

### تفاوت کلیدی برای مهندسین کامپیوتر
*   **`cat`:** کل فایل را می‌خواند و در RAM بارگذاری می‌کند و در خروجی می‌ریزد. برای فایل‌های متنی کوچک عالی است.
*   **`less`:** فایل را تکه به تکه (Buffer) می‌خواند. اگر بخواهید یک فایل ۵۰ گیگابایتی را باز کنید، `cat` ممکن است سیستم را فریز کند، اما `less` بلافاصله آن را باز می‌کند چون فقط صفحه اول را بارگذاری می‌کند.

---

## دستور `chmod` (Change Mode)

### مقدمه و مفهوم پایه
در لینوکس، هر فایل یا دایرکتوری دارای مجموعه‌ای از مجوزهاست که تعیین می‌کند چه کسی می‌تواند با آن چه کاری انجام دهد. دستور `chmod` (مخفف **Ch**ange **Mod**e) برای تغییر این مجوزها استفاده می‌شود.

برای درک `chmod`، ابتدا باید خروجی دستور `ls -l` را کالبدشکافی کنیم. وقتی `ls -l` می‌گیرید، در ابتدای خط عبارتی مثل `-rwxr-xr--` می‌بینید. این ۱۰ کاراکتر به ۴ بخش تقسیم می‌شوند:

1.  **کاراکتر اول:** نوع فایل (اگر `-` باشد یعنی فایل، اگر `d` باشد یعنی دایرکتوری).
2.  **سه کاراکتر بعدی (User/Owner):** مجوزهای **مالک** فایل (کسی که فایل را ساخته).
3.  **سه کاراکتر بعدی (Group):** مجوزهای **گروه** (کاربرانی که در یک تیم کاری هستند).
4.  **سه کاراکتر آخر (Others):** مجوزهای **بقیه** (هر کسی غیر از مالک و هم‌گروهی‌ها).

### انواع مجوزها (r, w, x)
سه نوع مجوز اصلی داریم که رفتارشان برای **فایل** و **دایرکتوری** متفاوت است:

| مجوز | نماد | برای فایل (File) | برای دایرکتوری (Directory) |
| :--- | :---: | :--- | :--- |
| **Read** | `r` | اجازه خواندن محتویات فایل (cat/open). | اجازه لیست گرفتن از محتویات پوشه (ls). |
| **Write** | `w` | اجازه تغییر متن و ذخیره فایل. | اجازه ایجاد، حذف و تغییر نام فایل‌ها **درون** آن پوشه. |
| **Execute** | `x` | اجازه اجرا کردن فایل (مثل اسکریپت یا برنامه). | اجازه ورود به پوشه (cd) و دسترسی به متادیتای فایل‌های درونش. |

> **نکته حیاتی:** داشتن مجوز Write روی یک فایل، به شما اجازه حذف آن فایل را نمی‌دهد! برای حذف یک فایل، شما باید مجوز Write روی **پوشه‌ای** که فایل در آن قرار دارد را داشته باشید.

### روش‌های استفاده از `chmod`

ما به دو روش می‌توانیم مجوزها را تغییر دهیم: **روش نمادین (Symbolic)** و **روش عددی (Octal/Numeric)**.

#### روش ۱: حالت نمادین (Symbolic Mode)
فرمول: `chmod [Who][Operator][Permission] filename`

*   **Who (چه کسی):** `u` (User), `g` (Group), `o` (Others), `a` (All - همه).
*   **Operator (عملگر):** `+` (اضافه کردن)، `-` (کم کردن)، `=` (تنظیم دقیق).
*   **Permission (مجوز):** `r`, `w`, `x`.

**مثال:**
```bash
chmod u+x script.py   # به مالک فایل اجازه اجرا بده
chmod go-w file.txt   # اجازه نوشتن را از گروه و بقیه بگیر
chmod a=r file.pdf    # همه فقط و فقط اجازه خواندن داشته باشند (بقیه مجوزها حذف می‌شود)
```

#### روش ۲: حالت عددی (Octal Mode) - روش حرفه‌ای‌ها
این روش بر مبنای سیستم اعداد باینری (دودویی) است و دانشجویان کامپیوتر باید به این روش مسلط باشند. هر مجوز یک ارزش عددی دارد:

*   **`r` (Read) = 4** (در باینری 100)
*   **`w` (Write) = 2** (در باینری 010)
*   **`x` (Execute) = 1** (در باینری 001)
*   **`-` (No permission) = 0**

ما جمع این اعداد را برای هر دسته (User, Group, Others) محاسبه می‌کنیم.

**مثال‌های رایج عددی:**

*   **`chmod 777` (خطرناک):**
    *   User: 4+2+1 = 7 (rwx)
    *   Group: 4+2+1 = 7 (rwx)
    *   Others: 4+2+1 = 7 (rwx)
    *   *نتیجه:* همه می‌توانند بخوانند، بنویسند و اجرا کنند. (در امنیت صفر است!)

*   **`chmod 755` (استاندارد اسکریپت‌ها و پوشه‌ها):**
    *   User: 7 (rwx) -> مالک همه کار می‌کند.
    *   Group: 4+0+1 = 5 (r-x) -> هم‌گروهی فقط می‌خواند و اجرا می‌کند.
    *   Others: 5 (r-x) -> بقیه هم فقط می‌خوانند و اجرا می‌کنند.

*   **`chmod 644` (استاندارد فایل‌های متنی):**
    *   User: 4+2 = 6 (rw-) -> مالک می‌خواند و می‌نویسد.
    *   Group: 4 (r--) -> فقط می‌خواند.
    *   Others: 4 (r--) -> فقط می‌خواند.

### مثال‌های عملی (Terminal Simulation)

**مثال ۱: تبدیل یک فایل متنی به یک برنامه اجرایی**
شما یک اسکریپت پایتون نوشته‌اید اما لینوکس اجازه اجرای آن را نمی‌دهد.
```bash
user@linux-machine:~$ ./hello.py
bash: ./hello.py: Permission denied

user@linux-machine:~$ chmod +x hello.py
user@linux-machine:~$ ./hello.py
Hello World!
```

**مثال ۲: مخفی کردن فایل شخصی (Private)**
می‌خواهید فایلی داشته باشید که هیچکس جز خودتان نتواند حتی آن را ببیند.
```bash
user@linux-machine:~$ chmod 600 secret.txt
user@linux-machine:~$ ls -l secret.txt
-rw------- 1 user user 0 Nov 30 10:00 secret.txt
```
*(کد ۶۰۰ یعنی: مالک (rw)، گروه (هیچ)، بقیه (هیچ))*

**مثال ۳: تغییر مجوز به صورت بازگشتی (Recursive)**
می‌خواهید مجوز تمام فایل‌ها و پوشه‌های داخل یک دایرکتوری `website` را تغییر دهید.
```bash
user@linux-machine:~$ chmod -R 755 website/
```
*نکته:* سوئیچ `-R` (بزرگ) برای اعمال تغییرات روی دایرکتوری و تمام فرزندانش استفاده می‌شود.

---

## دستورات `head` و `tail`

### ۱. دستور `head` (سر)

#### مقدمه و هدف
همانطور که از نامش پیداست، این دستور **ابتدای** فایل را نمایش می‌دهد. گاهی اوقات فقط می‌خواهیم ببینیم ساختار یک فایل CSV چگونه است یا هدرهای یک فایل چیست، و نیازی به باز کردن کل فایل نداریم.

#### سینتکس (Syntax)
```bash
head [OPTION]... [FILE]...
```
به صورت پیش‌فرض، ۱۰ خط اول فایل نمایش داده می‌شود.

#### سوئیچ‌های مهم
*   **`-n` (Number):** تعیین تعداد خطوطی که باید نمایش داده شود. (مثلاً `-n 5` یعنی ۵ خط اول).

#### مثال‌های عملی (Terminal Simulation)

**مثال ۱: چک کردن هدرهای یک دیتاست**
```bash
user@linux-machine:~$ head data.csv
Name,Age,City,Salary
Alice,30,New York,5000
Bob,25,Los Angeles,4000
Charlie,35,Chicago,6000
... (تا خط ۱۰)
```

**مثال ۲: مشاهده فقط ۳ خط اول**
```bash
user@linux-machine:~$ head -n 3config.yaml
version: '3'
services:
  web:
```

---

### ۲. دستور `tail` (دم)

#### مقدمه و هدف
این دستور برعکس `head` عمل می‌کند و **انتهای** فایل را نمایش می‌دهد. این دستور یکی از پرکاربردترین ابزارها برای مدیران سیستم (SysAdmins) و برنامه‌نویسان Backend است، چرا که جدیدترین اتفاقات در فایل‌های Log همیشه در انتهای فایل نوشته می‌شوند.

#### سینتکس (Syntax)
```bash
tail [OPTION]... [FILE]...
```
به صورت پیش‌فرض، ۱۰ خط آخر فایل نمایش داده می‌شود.

#### سوئیچ‌های مهم
*   **`-n` (Number):** تعیین تعداد خطوط آخر.
*   **`-f` (Follow):** این مهم‌ترین ویژگی `tail` است. با این سوئیچ، دستور تمام نمی‌شود؛ بلکه "منتظر" می‌ماند و هر خط جدیدی که به انتهای فایل اضافه شود را **به صورت زنده (Real-time)** در ترمینال نمایش می‌دهد.

#### مثال‌های عملی (Terminal Simulation)

**مثال ۱: دیدن آخرین خطاهای ثبت شده**
```bash
user@linux-machine:~$ tail -n 5 error_log.txt
2025-11-30 10:00:01 Error: Database connection failed
2025-11-30 10:00:02 Retrying connection...
2025-11-30 10:00:05 Connected successfully.
2025-11-30 10:05:00 Warning: High memory usage.
2025-11-30 10:05:10 Critical: Service crashed.
```

**مثال ۲: مانیتورینگ زنده (Live Monitoring) با `-f`**
فرض کنید سرور شما در حال اجراست و می‌خواهید ببینید همین الان چه درخواست‌هایی می‌آید.
```bash
user@linux-machine:~$ tail -f /var/log/apache2/access.log
192.168.1.5 - - [30/Nov/2025:10:15:00] "GET /index.html HTTP/1.1" 200
192.168.1.8 - - [30/Nov/2025:10:15:02] "POST /login HTTP/1.1" 302
```
*(ترمینال در اینجا قفل می‌شود و هر خط جدیدی که کاربرها روی سایت ایجاد کنند، اینجا چاپ می‌شود. برای خروج باید `Ctrl + C` را بزنید).*

### ترکیب کاربردی (Piping)
گاهی می‌خواهیم خطوط میانی را ببینیم (مثلاً خط ۱۱ تا ۲۰). می‌توان `head` و `tail` را با هم ترکیب کرد.

**مثال: نمایش خط ۱۱ تا ۱۵**
ابتدا ۱۵ خط اول را می‌گیریم، سپس ۵ خط آخر آن خروجی را برمی‌داریم:
```bash
user@linux-machine:~$ head -n 15 file.txt | tail -n 5
```
*(علامت `|` یا Pipe خروجی دستور سمت چپ را به عنوان ورودی به دستور سمت راست می‌دهد).*

---

## دستور `sort`

### مقدمه و هدف
دستور `sort` محتویات یک فایل متنی را خط به خط می‌خواند و آن‌ها را مرتب می‌کند. این مرتب‌سازی به صورت پیش‌فرض **الفبایی (ASCII)** است، اما با استفاده از سوئیچ‌ها می‌توان نحوه مرتب‌سازی را تغییر داد (مثلاً عددی، معکوس و ...). نکته مهم این است که `sort` فایل اصلی را تغییر نمی‌دهد، بلکه نتیجه مرتب شده را فقط در خروجی چاپ می‌کند (مگر اینکه خروجی را در فایل جدیدی ذخیره کنید).

### سینتکس (Syntax)
```bash
sort [OPTION]... [FILE]...
```

### سوئیچ‌های مهم
*   **`-n` (Numeric):** مرتب‌سازی بر اساس مقدار عددی. (بدون این سوئیچ، عدد `10` قبل از `2` می‌آید چون کاراکتر '1' قبل از '2' است!).
*   **`-r` (Reverse):** مرتب‌سازی را برعکس می‌کند (نزولی: Z به A یا ۹ به ۰).
*   **`-R` (Random):** خطوط را به صورت تصادفی بر می‌زند (Shuffle).
*   **`-u` (Unique):** پس از مرتب‌سازی، خطوط تکراری را حذف می‌کند (فقط یک نمونه از هر کدام نگه می‌دارد).
*   **`-k` (Key):** مشخص می‌کند بر اساس کدام ستون مرتب‌سازی انجام شود. (مثلاً `-k 2` یعنی بر اساس ستون دوم).

### مثال‌های عملی (Terminal Simulation)

فرض کنید فایلی به نام `scores.txt` با محتویات زیر داریم:
```text
Bob 85
Alice 100
Charlie 90
Bob 85
David 7
```

**مثال ۱: مرتب‌سازی ساده الفبایی (پیش‌فرض)**
```bash
user@linux-machine:~$ sort scores.txt
Alice 100
Bob 85
Bob 85
Charlie 90
David 7
```
*نکته:* کل خط بر اساس اولین حرف (نام‌ها) مرتب شد.

**مثال ۲: حذف تکراری‌ها**
```bash
user@linux-machine:~$ sort -u scores.txt
Alice 100
Bob 85
Charlie 90
David 7
```
*نکته:* یکی از `Bob 85` ها حذف شد.

**مثال ۳: مرتب‌سازی بر اساس نمره (ستون دوم) به صورت عددی**
اگر از `-n` استفاده نکنیم، `100` قبل از `7` قرار می‌گیرد (چون '1' < '7'). پس `-n` الزامی است. همچنین از `-k 2` استفاده می‌کنیم تا به ستون دوم (نمره) نگاه کند.

```bash
user@linux-machine:~$ sort -k 2 -n scores.txt
David 7
Bob 85
Bob 85
Charlie 90
Alice 100
```

**مثال ۴: بهترین نمره در بالا (عددی + معکوس)**
ترکیب `-n` و `-r` و `-k`.

```bash
user@linux-machine:~$ sort -k 2 -nr scores.txt
Alice 100
Charlie 90
Bob 85
Bob 85
David 7
```

### کاربرد ترکیبی (Piping)
دستور `sort` اغلب در انتهای یک پایپ لاین استفاده می‌شود.
مثلاً لیست فایل‌ها را بر اساس حجم مرتب کنیم (`ls -l` ستون حجم را در ستون پنجم نشان می‌دهد):

```bash
user@linux-machine:~$ ls -l | sort -k 5 -n
```
*(این دستور فایل‌ها را از کم‌حجم‌ترین به پرحجم‌ترین مرتب می‌کند).*

---

## دستور `nl` (Number Lines)

### مقدمه و هدف
دستور `nl` مخفف **Number Lines** است. وظیفه اصلی آن خواندن محتوای یک فایل و نمایش آن در خروجی به همراه **شماره خط** است.
شاید بپرسید "مگر `cat -n` همین کار را نمی‌کرد؟". پاسخ مثبت است، اما `nl` هوشمندتر و منعطف‌تر است. تفاوت اصلی و فنی این است که **`nl` به صورت پیش‌فرض خطوط خالی (Blank Lines) را شماره‌گذاری نمی‌کند**، در حالی که `cat -n` به همه خطوط شماره می‌دهد. این ویژگی باعث می‌شود خروجی `nl` برای خواندن کدهای منبع (Source Code) تمیزتر باشد.

### سینتکس (Syntax)
```bash
nl [OPTION]... [FILE]...
```

### سوئیچ‌های مهم
*   **`-b` (Body numbering):** تعیین سبک شماره‌گذاری بدنه متن.
    *   `-b t`: (پیش‌فرض) فقط خطوطی که متن دارند (Non-empty) شماره می‌گیرند.
    *   `-b a`: تمام خطوط (All)، حتی خطوط خالی شماره می‌گیرند (شبیه `cat -n`).
    *   `-b n`: هیچ خطی شماره‌گذاری نمی‌شود.
*   **`-s` (Separator):** تعیین کاراکتر جداکننده بین شماره و متن خط. (پیش‌فرض یک Tab است).
*   **`-w` (Width):** تعیین عرض ستون شماره‌ها.

### مثال‌های عملی (Terminal Simulation)

فرض کنید فایلی به نام `program.py` با محتویات زیر (شامل خطوط خالی برای خوانایی) داریم:

```python
import os

def main():
    print("Hello World")

main()
```

**مثال ۱: رفتار پیش‌فرض (نادیده گرفتن خطوط خالی)**
در این حالت فقط خطوطی که کد دارند شماره می‌گیرند. این برای ارجاع دادن به منطق برنامه عالی است.

```bash
user@linux-machine:~$ nl program.py
     1	import os

     2	def main():
     3	    print("Hello World")

     4	main()
```
*(مشاهده می‌کنید که خطوط خالی شماره نگرفتند).*

**مثال ۲: شماره‌گذاری تمام خطوط (مانند `cat -n`)**
اگر بخواهیم دقیقاً بدانیم فایل چند خط فیزیکی دارد، از `-b a` استفاده می‌کنیم.

```bash
user@linux-machine:~$ nl -b a program.py
     1	import os
     2
     3	def main():
     4	    print("Hello World")
     5
     6	main()
```

**مثال ۳: شخصی‌سازی فرمت (تزئین خروجی)**
فرض کنید می‌خواهیم شماره‌ها با فرمت خاصی مثل `1. ` نمایش داده شوند و عرض ستون شماره‌ها کم باشد.
*   `-w 2`: عرض ستون شماره ۲ کاراکتر باشد.
*   `-s ". "`: بعد از شماره، یک نقطه و فاصله بیاید.

```bash
user@linux-machine:~$ nl -w 2 -s ". " program.py
 1. import os

 2. def main():
 3.     print("Hello World")

 4. main()
```

### کاربرد ترکیبی
این دستور معمولاً برای چاپ کردن کدها جهت بررسی چشمی (Code Review) استفاده می‌شود. مثلاً ترکیب با `head` برای دیدن ۱۰ خط اول کد به همراه شماره:

```bash
user@linux-machine:~$ nl program.py | head
```

---


## دستور `wc` (Word Count)

### مقدمه و هدف
دستور `wc` مخفف **Word Count** است. اگرچه نامش فقط به "شمارش کلمات" اشاره دارد، اما این دستور اطلاعات آماری مهمی شامل **تعداد خطوط (Lines)**، **تعداد کلمات (Words)** و **تعداد بایت‌ها (Bytes/Size)** یک فایل یا ورودی را محاسبه می‌کند.
برای مهندسین کامپیوتر، این دستور اغلب برای شمارش تعداد فایل‌ها، بررسی حجم لاگ‌ها یا شمارش تعداد خطوط کد (LOC) استفاده می‌شود.

### سینتکس (Syntax)
```bash
wc [OPTION]... [FILE]...
```

### سوئیچ‌های مهم
*   **`-l` (Lines):** فقط تعداد خطوط را نمایش می‌دهد (پرکاربردترین سوئیچ).
*   **`-w` (Words):** فقط تعداد کلمات را نمایش می‌دهد.
*   **`-c` (Bytes):** تعداد بایت‌ها (حجم فایل) را نمایش می‌دهد.
*   **بدون سوئیچ:** هر سه مورد (خط، کلمه، بایت) را به ترتیب نمایش می‌دهد.

### مثال‌های عملی (Terminal Simulation)

فرض کنید فایلی به نام `message.txt` با محتوای زیر داریم:
```text
Hello Linux
Welcome to Engineering
```

**مثال ۱: رفتار پیش‌فرض (اطلاعات کامل)**
در این حالت خروجی شامل ۳ عدد است. ترتیب آن‌ها استاندارد و همیشگی است: **خط، کلمه، بایت**.

```bash
user@linux-machine:~$ wc message.txt
 2  5 34 message.txt
```
*   **۲:** تعداد خطوط.
*   **۵:** تعداد کلمات (`Hello`, `Linux`, `Welcome`, `to`, `Engineering`).
*   **۳۴:** تعداد بایت‌ها (شامل کاراکترها، فضاها و کاراکتر نامرئی Enter یا Newline).

**مثال ۲: فقط شمارش خطوط (مهم برای برنامه‌نویسی)**
فرض کنید می‌خواهید بدانید فایل کد `main.c` چند خط است.

```bash
user@linux-machine:~$ wc -l main.c
150 main.c
```

**مثال ۳: استفاده قدرتمند با Pipe (شمارش فایل‌ها)**
دستور `wc` اغلب ورودی خود را از خروجی یک دستور دیگر می‌گیرد.
فرض کنید می‌خواهید بدانید **"چند فایل و پوشه در دایرکتوری فعلی وجود دارد؟"**.
دستور `ls` لیست را می‌دهد و ما آن لیست را به `wc` می‌دهیم تا خطوطش را بشمارد.

```bash
user@linux-machine:~$ ls -1 | wc -l
12
```
*   `ls -1`: فایل‌ها را در یک ستون (هر فایل در یک خط) لیست می‌کند.
*   `|`: خروجی را پاس می‌دهد.
*   `wc -l`: خطوط ورودی را می‌شمارد.
*   **نتیجه:** ۱۲ فایل/پوشه در این مسیر وجود دارد.

**مثال ۴: شمارش کاربران سیستم**
فایل `/etc/passwd` حاوی لیست کاربران است. چند کاربر در سیستم تعریف شده‌اند؟

```bash
user@linux-machine:~$ wc -l /etc/passwd
45 /etc/passwd
```

---

## دستور `sed` (Stream Editor)

### مقدمه و هدف
دستور `sed` یک ویرایشگر متن است، اما نه مثل Notepad یا Word! شما فایلی را باز نمی‌کنید تا در آن تایپ کنید. بلکه به `sed` دستور می‌دهید که **"چگونه"** متن را تغییر دهد و `sed` این کار را روی یک فایل یا جریان ورودی انجام می‌دهد.
کاربرد اصلی آن **یافتن و جایگزین کردن (Search & Replace)**، حذف خطوط خاص، یا استخراج بخش‌هایی از فایل به صورت خودکار و بدون باز کردن فایل است. این ابزار در اسکریپت‌نویسی برای اتوماسیون تغییرات در فایل‌های تنظیمات (Config files) بی‌نظیر است.

### سینتکس (Syntax)
ساختار کلی دستور `sed` کمی متفاوت است و معمولاً داخل کوتیشن `'...'` نوشته می‌شود:
```bash
sed [OPTIONS] 'command' file
```

### مفهوم Substitution (جایگزینی) - پرکاربردترین دستور
رایج‌ترین فرم استفاده از `sed` برای جایگزینی متن است که با حرف `s` (substitute) شروع می‌شود:
`s/old-text/new-text/flags`

*   **old-text:** متنی که دنبالش می‌گردیم (می‌تواند Regex باشد).
*   **new-text:** متنی که جایگزین می‌شود.
*   **flags:** نحوه جایگزینی (مثلاً `g` برای همه موارد در یک خط).

### سوئیچ‌های مهم
*   **`-i` (In-place):** بسیار مهم! به صورت پیش‌فرض `sed` تغییرات را فقط در صفحه نمایش نشان می‌دهد و فایل اصلی را دست‌نخورده باقی می‌گذارد (برای تست امن است). اگر می‌خواهید تغییرات **روی خود فایل ذخیره شود**، باید از `-i` استفاده کنید.

### مثال‌های عملی (Terminal Simulation)

فرض کنید فایلی به نام `greetings.txt` داریم:
```text
Hello World
Hello Linux
Hello World, Hello Universe
```

**مثال ۱: جایگزینی ساده (فقط اولین مورد در هر خط)**
می‌خواهیم `Hello` را به `Hi` تغییر دهیم.
```bash
user@linux-machine:~$ sed 's/Hello/Hi/' greetings.txt
Hi World
Hi Linux
Hi World, Hello Universe
```
*نکته:* در خط سوم، فقط `Hello` اول تغییر کرد. این رفتار پیش‌فرض است.

**مثال ۲: جایگزینی سراسری (Global)**
برای اینکه تمام `Hello`ها در خط تغییر کنند، از پرچم `g` در انتهای دستور استفاده می‌کنیم.
```bash
user@linux-machine:~$ sed 's/Hello/Hi/g' greetings.txt
Hi World
Hi Linux
Hi World, Hi Universe
```

**مثال ۳: حذف خطوط خاص**
دستور `d` (delete) برای حذف خطوط استفاده می‌شود.
*   حذف خط دوم:
```bash
user@linux-machine:~$ sed '2d' greetings.txt
Hello World
Hello World, Hello Universe
```
*   حذف تمام خطوطی که شامل کلمه "Linux" هستند (استفاده از الگو):
```bash
user@linux-machine:~$ sed '/Linux/d' greetings.txt
Hello World
Hello World, Hello Universe
```

**مثال ۴: اعمال تغییرات روی فایل اصلی (مهم)**
تا اینجا فقط خروجی را در ترمینال دیدیم. برای تغییر دائم فایل تنظیمات، مثلاً تغییر پورت در فایل `config.conf`:
محتوای فایل: `PORT=8080`
```bash
user@linux-machine:~$ sed -i 's/8080/9000/' config.conf
```
حالا اگر `cat config.conf` را بزنید، `PORT=9000` را خواهید دید.

### کاربرد در پایپ (Pipe)
`sed` می‌تواند خروجی دستورات دیگر را هم فیلتر کند. مثلاً مخفی کردن آدرس IP در خروجی لاگ:
```bash
user@linux-machine:~$ cat server.log | sed 's/192.168.1.1/xxx.xxx.xxx.xxx/g'
```

---

## دستور `uniq` (Unique)

### مقدمه و هدف
دستور `uniq` خطوط تکراری **پشت سر هم (Adjacent)** را فیلتر یا گزارش می‌کند.
نکته کلیدی و بسیار مهمی که اغلب دانشجویان را به اشتباه می‌اندازد این است: **`uniq` تکراری‌هایی را که پشت سر هم نباشند تشخیص نمی‌دهد.**
به همین دلیل است که **همیشه** قبل از استفاده از `uniq`، باید ورودی را با دستور `sort` مرتب کنیم تا تکراری‌ها کنار هم قرار بگیرند.

### سینتکس (Syntax)
```bash
uniq [OPTION]... [INPUT [OUTPUT]]
```

### سوئیچ‌های مهم
*   **`-c` (Count):** به جای حذف تکراری‌ها، تعداد تکرار هر خط را در ابتدای آن چاپ می‌کند. (بسیار پرکاربرد برای آمارگیری).
*   **`-u` (Unique):** فقط خطوطی را چاپ می‌کند که اصلاً تکرار نشده‌اند (منحصر به فرد واقعی).
*   **`-d` (Duplicate):** فقط خطوطی را چاپ می‌کند که تکراری بوده‌اند (برای پیدا کردن داده‌های تکراری).

### مثال‌های عملی (Terminal Simulation)

فرض کنید فایلی به نام `fruits.txt` داریم که مرتب نشده است:
```text
Apple
Banana
Apple
Cherry
Banana
Banana
```

**مثال ۱: اشتباه رایج (استفاده بدون `sort`)**
اگر مستقیم `uniq` را بزنیم، هیچ اتفاق خاصی نمی‌افتد چون `Apple` دوم با `Apple` اول فاصله دارد.
```bash
user@linux-machine:~$ uniq fruits.txt
Apple
Banana
Apple
Cherry
Banana
```
*(تغییری نکرد، فقط آخرین Banana که دوتایی بود یکی شد).*

**مثال ۲: روش صحیح (ترکیب با `sort`)**
ابتدا مرتب می‌کنیم تا هم‌نام‌ها کنار هم بیایند، سپس به `uniq` می‌دهیم.
```bash
user@linux-machine:~$ sort fruits.txt | uniq
Apple
Banana
Cherry
```
*(حالا لیستی تمیز و بدون تکرار داریم).*

**مثال ۳: شمارش تکرارها (آمارگیری)**
می‌خواهیم بدانیم از هر میوه چند تا داریم. این یکی از قدرتمندترین ترکیب‌های لینوکس است.
```bash
user@linux-machine:~$ sort fruits.txt | uniq -c
      2 Apple
      3 Banana
      1 Cherry
```

**مثال ۴: پیدا کردن فقط تکراری‌ها**
فرض کنید لیستی از کدهای دانشجویی دارید و می‌خواهید ببینید کدام کدها اشتباهاً دو بار وارد شده‌اند.
```bash
user@linux-machine:~$ sort student_ids.txt | uniq -d
9912345
9912388
```
*(این خروجی نشان می‌دهد که فقط این دو شماره دانشجویی تکرار شده‌اند).*

**مثال ۵: مرتب‌سازی بر اساس فراوانی**
یک ترکیب حرفه‌ای برای دانشجویان مهندسی:
می‌خواهیم ببینیم کدام میوه **بیشترین** تکرار را داشته است.
1. `sort`: مرتب‌سازی اولیه.
2. `uniq -c`: شمارش.
3. `sort -nr`: مرتب‌سازی مجدد (عددی و معکوس) برای اینکه بیشترین عدد بالا بیاید.

```bash
user@linux-machine:~$ sort fruits.txt | uniq -c | sort -nr
      3 Banana
      2 Apple
      1 Cherry
```

---

## دستور `tac` (Reverse Cat)

### مقدمه و هدف
همان‌طور که از اسمش پیداست (برعکس کلمه `cat`)، این دستور محتویات یک فایل را نمایش می‌دهد، اما **از خط آخر به خط اول**.
اگر `cat` فایل را از سر به ته می‌خواند، `tac` آن را از ته به سر می‌خواند.
**کاربرد اصلی:** زمانی که فایل‌های لاگ (Log) طولانی دارید و می‌خواهید آخرین رخدادها (که در انتهای فایل نوشته شده‌اند) را در بالای ترمینال ببینید، یا زمانی که می‌خواهید اولویت یک لیست مرتب شده را معکوس کنید.

### سینتکس (Syntax)
```bash
tac [OPTION]... [FILE]...
```

### تفاوت با `tail`
*   **`tail`:** انتهای فایل را نشان می‌دهد، اما ترتیب خطوط را حفظ می‌کند (خط ۱۰، بعد خط ۱۱، بعد ۱۲).
*   **`tac`:** کل فایل را برعکس می‌کند (اول خط ۱۲، بعد خط ۱۱، بعد خط ۱۰).

### مثال‌های عملی (Terminal Simulation)

فرض کنید فایلی به نام `steps.txt` داریم که مراحل یک کار را به ترتیب نوشته است:
```text
Step 1: Installation
Step 2: Configuration
Step 3: Execution
Step 4: Finish
```

**مثال ۱: معکوس کردن ترتیب فایل**
می‌خواهیم این مراحل را از آخر به اول ببینیم.
```bash
user@linux-machine:~$ tac steps.txt
Step 4: Finish
Step 3: Execution
Step 2: Configuration
Step 1: Installation
```

**مثال ۲: مشاهده لاگ‌ها (جدیدترین در بالا)**
فرض کنید یک فایل لاگ سرور دارید. معمولاً جدیدترین خطاها در پایین فایل هستند. با `tac` می‌توانید جدیدترین خطا را در اولین خط خروجی ببینید.
فایل `server.log`:
```text
[10:00] Server started
[10:15] User login
[10:20] CRITICAL ERROR
```

اجرای دستور:
```bash
user@linux-machine:~$ tac server.log
[10:20] CRITICAL ERROR
[10:15] User login
[10:00] Server started
```

**مثال ۳: ترکیب با `head` (ترکیب هوشمندانه)**
اگر فایل لاگ شما ۱۰۰۰ خط باشد، `tac` همه ۱۰۰۰ خط را برعکس چاپ می‌کند که شلوغ می‌شود. برای دیدن **۵ خط آخر فایل، اما به صورت معکوس** (یعنی جدیدترین خط، اولین خط باشد)، از پایپ استفاده می‌کنیم:

```bash
user@linux-machine:~$ tac server.log | head -n 2
[10:20] CRITICAL ERROR
[10:15] User login
```
*(این دستور ابتدا فایل را سر-ته می‌کند، سپس ۲ خط اولِ نتیجه‌ی سر-ته شده را جدا می‌کند).*

---

## دستور `ps` (Process Status)

### مقدمه و هدف
در لینوکس، هر برنامه‌ای که اجرا می‌شود (حتی یک دستور ساده `ls`) یک **Process** (فرآیند) نامیده می‌شود. سیستم‌عامل به هر فرآیند یک شناسه یکتا به نام **PID (Process ID)** اختصاص می‌دهد.
دستور `ps` یک "عکس فوری" (Snapshot) از فرآیندهای در حال اجرای سیستم در همان لحظه می‌گیرد و نمایش می‌دهد. (برخلاف `top` که زنده و متحرک است).

### ۱. دستور `ps` (حالت ساده)
اگر این دستور را بدون هیچ آرگومانی اجرا کنید، اطلاعات بسیار محدودی به شما می‌دهد. فقط پروسه‌هایی را نشان می‌دهد که:
1.  متعلق به کاربر جاری هستند.
2.  در همین ترمینال (Shell) جاری اجرا شده‌اند.

**مثال شبیه‌سازی شده:**
```bash
user@linux-machine:~$ ps
  PID TTY          TIME CMD
 3450 pts/0    00:00:00 bash
 3485 pts/0    00:00:00 ps
```
*   **PID:** شناسه پروسه (عدد مهم برای مدیریت آن).
*   **TTY:** ترمینالی که دستور در آن اجرا شده.
*   **CMD:** نام دستور یا برنامه.

---

### ۲. دستور `ps aux` (استاندارد حرفه‌ای)
این پرکاربردترین حالت استفاده از `ps` در دنیای واقعی است. فرمت آن استایل BSD دارد (بدون خط تیره هم کار می‌کند) و برای دیدن **"همه چیز"** استفاده می‌شود.

**تحلیل سوئیچ‌ها:**
*   **`a` (All):** نمایش فرآیندهای همه کاربران (نه فقط کاربر شما) که به یک ترمینال متصل هستند.
*   **`u` (User-oriented):** نمایش اطلاعات با جزئیات بیشتر (مثل مصرف CPU، رم، مالک پروسه و...).
*   **`x`:** نمایش فرآیندهایی که به هیچ ترمینالی متصل نیستند (بسیار مهم: شامل سرویس‌های پس‌زمینه یا Daemons مثل وب‌سرورها، دیتابیس‌ها و... می‌شود).

**مثال شبیه‌سازی شده:**
```bash
user@linux-machine:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1 102540  6500 ?        Ss   09:00   0:02 /sbin/init
root       854  0.1  2.5 540120 98500 ?        Ssl  09:01   1:15 /usr/bin/dockerd
www-data  1050  0.0  0.5 450100 20100 ?        S    09:05   0:05 nginx: worker process
user      2022  5.5  1.2 950200 45100 pts/1    Sl+  10:15   0:12 python3 heavy_script.py
```

**تفسیر ستون‌های مهم:**
*   **USER:** کاربری که برنامه را اجرا کرده (مثلاً `root` یا `www-data`).
*   **PID:** شناسه عددی پروسه (اگر بخواهید برنامه‌ای را ببندید یا `kill` کنید، به این عدد نیاز دارید).
*   **%CPU / %MEM:** درصد مصرف پردازنده و رم. (برای پیدا کردن برنامه‌هایی که سیستم را کند کرده‌اند عالی است).
*   **COMMAND:** مسیر کامل دستور اجرایی.

### ترکیب طلایی: `ps aux | grep`
خروجی `ps aux` معمولاً صدها خط است و پیدا کردن یک برنامه خاص در آن دشوار است. مهندسان همیشه آن را با `grep` ترکیب می‌کنند.

**مثال:** پیدا کردن پروسه‌های مربوط به پایتون
```bash
user@linux-machine:~$ ps aux | grep python
user      2022  5.5  1.2 950200 45100 pts/1    Sl+  10:15   0:12 python3 heavy_script.py
user      2025  0.0  0.0   4500   800 pts/1    S+   10:16   0:00 grep python
```
*(خط دوم خود دستور جستجوگر grep است که در لیست پروسه‌ها دیده می‌شود).*

---

## دستور `kill`

### مقدمه و هدف
گاهی اوقات برنامه‌ها هنگ می‌کنند (Hang)، پاسخ نمی‌دهند، یا بیش از حد منابع سیستم را مصرف می‌کنند. دستور `kill` ابزاری برای ارسال "سیگنال" به پروسه‌ها است تا به آنها بگوید کارشان را تمام کنند.
برای استفاده از این دستور، شما حتماً باید **PID (Process ID)** آن برنامه را بدانید (که با دستور `ps aux` یا `top` به دست می‌آید).

### سینتکس (Syntax)
```bash
kill [OPTIONS] PID
```

### ۱. دستور `kill PID` (خاتمه مودبانه - حالت پیش‌فرض)
اگر هیچ سوئیچی نگذارید، سیستم سیگنال شماره ۱۵ یا **SIGTERM (Terminate)** را ارسال می‌کند.
این "مودبانه‌ترین" روش بستن یک برنامه است. به برنامه می‌گوید: *"لطفاً، اگر کارت تمام شد و فایل‌های بازت را بستی، خودت را خاموش کن."* برنامه فرصت دارد فایل‌ها را ذخیره کند و تمیز خارج شود.

**مثال شبیه‌سازی شده:**
فرض کنید فایرفاکس با PID شماره `3450` در حال اجراست.
```bash
user@linux-machine:~$ kill 3450
```
*(در بیشتر موارد برنامه بسته می‌شود).*

---

### ۲. دستور `kill -9 PID` (تیر خلاص - اجباری)
اگر یک برنامه شدیداً هنگ کرده باشد ("Zombie" شده باشد) یا به درخواست مودبانه `SIGTERM` پاسخ ندهد، از سیگنال شماره ۹ یا **SIGKILL** استفاده می‌کنیم.
این دستور به هسته لینوکس (Kernel) می‌گوید: *"اصلاً از برنامه نپرس! همین الان فرآیندش را از حافظه پاک کن."*
برنامه هیچ فرصتی برای ذخیره اطلاعات یا بستن فایل‌ها نخواهد داشت (مثل کشیدن کابل برق کامپیوتر برای آن برنامه خاص).

**مثال شبیه‌سازی شده:**
یک اسکریپت پایتون با PID `5022` هنگ کرده و با دستور معمولی بسته نمی‌شود.
```bash
user@linux-machine:~$ kill -9 5022
```
*(برنامه بلافاصله ناپدید می‌شود).*

### سایر روش‌های کاربردی (اختیاری برای دانشجو)
*   **`killall firefox`:** این دستور به جای عدد PID، نام برنامه را می‌گیرد و تمام پنجره‌های فایرفاکس را می‌بندد (بسیار راحت‌تر است، اما باید دقیق باشید).

**نکات ایمنی برای دانشجویان:**
1.  **هرگز** `kill -9` را به عنوان اولین راه حل استفاده نکنید. ممکن است فایل‌های دیتابیس یا تنظیمات برنامه خراب شود (Corrupted). همیشه اول `kill` عادی را بزنید، اگر نشد، سراغ `-9` بروید.
2.  شما فقط می‌توانید پروسه‌های **خودتان** را ببندید. برای بستن پروسه‌های سیستمی یا سایر کاربران، باید از `sudo` استفاده کنید (مثلاً: `sudo kill -9 1234`).

---

## جستجو و فیلتر پیشرفته: `grep`، `egrep` و `regex`

### ۱. دستور `grep` (Global Regular Expression Print)

**هدف:**
جستجوی یک متن یا الگو (Pattern) در داخل فایل‌ها. اگر `ls` برای لیست کردن فایل‌هاست، `grep` برای جستجوی **محتوای** آن‌هاست.

**سینتکس (Syntax):**
```bash
grep [OPTIONS] PATTERN [FILE...]
```

**سوئیچ‌های حیاتی:**
*   **`-i` (Ignore Case):** حساس نبودن به بزرگی و کوچکی حروف (ALI = ali).
*   **`-r` (Recursive):** جستجو در تمام فایل‌ها و پوشه‌های تودرتو.
*   **`-n` (Line Number):** نمایش شماره خطی که متن در آن پیدا شده.
*   **`-v` (Invert Match):** نمایش خطوطی که **شامل الگوی مورد نظر نیستند** (برعکس کردن جستجو).
*   **`-c` (Count):** فقط تعداد خطوط پیدا شده را می‌شمارد.

**مثال شبیه‌سازی شده (پایه):**
فایل `students.txt`:
```text
Ali     Computer
Reza    Electrical
Sara    Computer
Mina    Art
```

جستجوی کلمه "Computer":
```bash
user@linux-machine:~$ grep "Computer" students.txt
Ali     Computer
Sara    Computer
```

جستجوی هر چیزی **به جز** کامپیوتر (`-v`):
```bash
user@linux-machine:~$ grep -v "Computer" students.txt
Reza    Electrical
Mina    Art
```

---

### ۲. آموزش جامع Regular Expressions (عبارات باقاعده)

رگولار اکسپرشن (یا Regex) یک "زبان" برای توصیف الگوهای متنی است. ما به جای جستجوی یک کلمه ثابت (مثل "Ali")، یک الگو تعریف می‌کنیم (مثل "هر کلمه‌ای که با A شروع شود و ۳ حرفی باشد").

این مبحث به ۳ دسته تقسیم می‌شود:
1.  **لنگرها (Anchors):** موقعیت را تعیین می‌کنند.
2.  **کلاس‌های کاراکتر (Character Sets):** چه حروفی مجاز هستند.
3.  **تکرارگرها (Quantifiers):** چند بار تکرار شود.

#### الف) لنگرها (Anchors) - "کجای خط؟"
*   **`^` (Carrot):** نشان‌دهنده **ابتدا**ی خط.
    *   الگو: `^Error` $\leftarrow$ فقط خطوطی که با کلمه Error شروع می‌شوند.
*   **`$` (Dollar):** نشان‌دهنده **انتها**ی خط.
    *   الگو: `OK$` $\leftarrow$ فقط خطوطی که با کلمه OK تمام می‌شوند.
    *   الگو: `^$` $\leftarrow$ خطوط کاملاً خالی (شروع و پایان به هم چسبیده‌اند).

#### ب) کاراکترهای خاص و مجموعه‌ها
*   **`.` (نقطه):** نماینده **هر** کاراکتری (به جز خط جدید).
    *   الگو: `b.g` $\leftarrow$ کلماتی مثل big, bag, bog, b@g را پیدا می‌کند.
*   **`[...]` (براکت):** مجموعه‌ای از کاراکترهای مجاز برای **یک** جایگاه.
    *   الگو: `b[ae]g` $\leftarrow$ فقط bag و beg را پیدا می‌کند (big را پیدا نمی‌کند).
*   **`[ - ]` (بازه):** تعریف محدوده.
    *   `[a-z]`: تمام حروف کوچک.
    *   `[0-9]`: تمام اعداد.
    *   `[a-zA-Z0-9]`: تمام حروف و اعداد.
*   **`[^...]` (نقیض):** هر چیزی **به جز** داخل براکت.
    *   الگو: `[^0-9]` $\leftarrow$ هر کاراکتری که عدد **نباشد**.

#### ج) تکرارگرها (Quantifiers) - "چند تا؟"
*نکته مهم:* در `grep` معمولی، برخی از این‌ها نیاز به `\` (Backslash) دارند، اما در `egrep` (که در ادامه می‌گوییم) مستقیم کار می‌کنند.

*   **`*` (ستاره):** کاراکتر قبلی **صفر بار یا بیشتر** تکرار شود. (دقت کنید! با `*` در دستور `ls` فرق دارد).
    *   الگو: `ab*c` $\leftarrow$ موارد ac (بدون b)، abc, abbc, abbbc را پیدا می‌کند.
*   **`?` (سوال):** کاراکتر قبلی **صفر یا یک بار** تکرار شود (اختیاری بودن).
    *   الگو: `colou?r` $\leftarrow$ هم color (آمریکایی) و هم colour (بریتیش) را پیدا می‌کند.
*   **`+` (جمع):** کاراکتر قبلی **یک بار یا بیشتر** تکرار شود (حداقل یکی باید باشد).
    *   الگو: `Go+gle` $\leftarrow$ باید حداقل یک o باشد (Google, Gooogle). کلمه Gogle پیدا نمی‌شود.

---

### ۳. دستور `egrep` (Extended Grep) یا `grep -E`

دستور `grep` معمولی برخی از نمادهای پیشرفته Regex (مثل `+`, `?`, `|`, `()`) را به عنوان کاراکتر معمولی می‌شناسد مگر اینکه قبلش `\` بگذارید.
برای راحتی کار، از `egrep` (یا معادل استاندارد آن `grep -E`) استفاده می‌کنیم که **Extended Regex** را پشتیبانی می‌کند.

**قابلیت‌های اضافه در `egrep`:**

1.  **گروه‌بندی `(...)`:**
    برای اعمال تکرار روی یک کلمه کامل یا محدود کردن دامنه انتخاب.
    *   مثال: `(ha)+` $\leftarrow$ عبارت ha یک یا چند بار تکرار شود (haha, hahaha).

2.  **عملگر "یا" `|` (Pipe):**
    *   مثال: `cat|dog` $\leftarrow$ خطوطی که کلمه cat **یا** کلمه dog را دارند.
    *   ترکیب با پرانتز: `gr(a|e)y` $\leftarrow$ پیدا کردن gray یا grey.

---

### مثال‌های عملی و پیچیده (Terminal Simulation)

فرض کنید فایل `server_log.txt` داریم:
```text
INFO: Server started at 10:00
ERROR: Database connection failed
WARNING: High memory usage (90%)
info: user login
Error: disk full 100%
Fail
File123.txt
```

**مثال ۱: استفاده از لنگرها (پیدا کردن خطوطی که دقیقاً با ERROR شروع می‌شوند)**
```bash
user@linux-machine:~$ grep "^ERROR" server_log.txt
ERROR: Database connection failed
```
*(خط ۵ که با Error کوچک شروع شده یا خطی که وسطش error باشد را نمی‌آورد).*

**مثال ۲: استفاده از کلاس کاراکتر (پیدا کردن اعداد)**
می‌خواهیم خطوطی را پیدا کنیم که حداقل یک عدد ۳ رقمی دارند.
الگو: `[0-9]` یعنی عدد، `{3}` یعنی ۳ بار تکرار (در egrep).
```bash
user@linux-machine:~$ egrep "[0-9]{3}" server_log.txt
Error: disk full 100%
File123.txt
```

**مثال ۳: استفاده از "یا" و "حساس نبودن به حروف" (جستجوی تمام خطاها)**
می‌خواهیم تمام Warningها و Errorها را (چه بزرگ چه کوچک) پیدا کنیم.
```bash
user@linux-machine:~$ egrep -i "warning|error|fail" server_log.txt
ERROR: Database connection failed
WARNING: High memory usage (90%)
Error: disk full 100%
Fail
```

**مثال ۴: الگوی واقعی (اعتبارسنجی ایمیل ساده)**
فرض کنید می‌خواهیم در یک فایل متنی دنبال ایمیل بگردیم.
الگو: `[a-zA-Z0-9._]+@[a-zA-Z0-9]+\.[a-z]+`
*   `[a-zA-Z0-9._]+`: نام کاربری (حروف، عدد، نقطه، خط زیر) - حداقل یکی (`+`).
*   `@`: علامت اتساین.
*   `[a-zA-Z0-9]+`: نام دامین.
*   `\.`: خودِ نقطه (چون نقطه خالی یعنی "هر چیزی"، پس باید Escape شود).
*   `[a-z]+`: پسوند دامین.

```bash
user@linux-machine:~$ egrep "[a-zA-Z0-9._]+@[a-zA-Z0-9]+\.[a-z]+" emails.txt
support@google.com
ali.reza_2025@yahoo.com
```

---

## دستور `history` (تاریخچه فرمان‌ها)

### مقدمه و هدف
آیا تا به حال دستوری طولانی و پیچیده (مثل یک `grep` یا `find` طولانی) تایپ کرده‌اید و بعداً فراموش کرده‌اید دقیقاً چه بود؟ لینوکس حافظه خوبی دارد! دستور `history` لیستی از دستوراتی که قبلاً اجرا کرده‌اید را نمایش می‌دهد. این دستور برای تکرار کارهای قبلی یا بررسی اینکه "من دقیقاً چه خرابکاری‌ای کردم!" بسیار مفید است.

### نحوه استفاده
```bash
history [number]
```
*   اگر بدون عدد اجرا شود، کل تاریخچه ذخیره شده را نشان می‌دهد.
*   اگر با عدد اجرا شود (مثلاً `history 10`)، فقط ۱۰ دستور آخر را نشان می‌دهد.

### میانبرهای جادویی (بسیار مهم برای سرعت)

۱. **اجرای مجدد دستور با شماره خط (`!n`):**
   وقتی خروجی `history` را می‌بینید، کنار هر دستور یک شماره وجود دارد.
   ```bash
   user@linux-machine:~$ history
   ...
   501  ls -l
   502  sudo apt update
   503  grep -r "error" /var/log
   ```
   اگر تایپ کنید `!503` و اینتر بزنید، دستور `grep` دوباره اجرا می‌شود.

۲. **اجرای مجدد آخرین دستور (`!!`):**
   این میانبر بسیار محبوب است. مثلاً وقتی فراموش کرده‌اید قبل از یک دستور `sudo` بگذارید:
   ```bash
   user@linux-machine:~$ apt update
   Error: Permission denied.
   
   user@linux-machine:~$ sudo !! 
   # این معادل sudo apt update اجرا می‌شود
   ```

۳. **جستجوی معکوس (`Ctrl + r`):**
   این بهترین روش جستجو در تاریخچه است.
   *   کلیدهای `Ctrl` و `r` را همزمان فشار دهید.
   *   ترمینال به حالت `(reverse-i-search)` می‌رود.
   *   شروع به تایپ بخشی از دستور قدیمی کنید (مثلاً `grep`).
   *   لینوکس آخرین دستوری که شامل آن کلمه بود را نشان می‌دهد.
   *   اگر باز هم `Ctrl + r` بزنید، به موارد قدیمی‌تر می‌رود.

### پاک کردن تاریخچه
برای امنیت (مثلاً اگر اشتباهی پسوردی را تایپ کرده‌اید که در تاریخچه مانده)، می‌توانید تاریخچه را پاک کنید:
*   **`history -c`**: کل تاریخچه فعلی را پاک می‌کند (Clear).

---

## دستورات تغییر مسیر (Redirection) و پایپ (Pipe)

### مقدمه فنی
در لینوکس، هر برنامه به صورت پیش‌فرض ۳ جریان داده (Stream) دارد:
1.  **ورودی استاندارد (stdin - 0):** معمولاً کیبورد.
2.  **خروجی استاندارد (stdout - 1):** معمولاً صفحه نمایش (ترمینال).
3.  **خطای استاندارد (stderr - 2):** پیام‌های خطا که معمولاً به صفحه نمایش می‌روند.

ما با استفاده از کاراکترهای خاص می‌توانیم مسیر این جریان‌ها را تغییر دهیم. مثلاً خروجی را به جای مانیتور، در یک فایل ذخیره کنیم.

---

### ۱. خروجی به فایل (`>`) - Overwrite
**هدف:** ذخیره خروجی یک دستور در یک فایل.
**نکته مهم:** اگر فایل وجود داشته باشد، محتویات قبلی آن **پاک شده** و محتوای جدید جایگزین می‌شود (Overwrite).

**مثال:** ذخیره لیست فایل‌ها در یک فایل متنی.
```bash
user@linux-machine:~$ ls -l > file_list.txt
```
*(هیچ چیزی در ترمینال چاپ نمی‌شود، همه چیز در فایل `file_list.txt` نوشته شد)*.

---

### ۲. الحاق به فایل (`>>`) - Append
**هدف:** اضافه کردن خروجی یک دستور به **انتهای** یک فایل موجود.
**نکته مهم:** محتویات قبلی فایل حفظ می‌شوند. این روش برای ساخت فایل‌های لاگ (Log) عالی است.

**مثال:** اضافه کردن تاریخ امروز به انتهای فایل لاگ.
```bash
user@linux-machine:~$ date >> my_log.txt
```

---

### ۳. ورودی از فایل (`<`)
**هدف:** خواندن داده‌ها از یک فایل به جای کیبورد.
بسیاری از دستورات به صورت خودکار نام فایل را به عنوان آرگومان می‌گیرند (مثل `cat file.txt`)، اما برخی دستورات ورودی را از stdin می‌خواهند.

**مثال:** استفاده از دستور `wc` (Word Count) برای شمارش خطوط یک فایل خاص.
```bash
user@linux-machine:~$ wc -l < my_log.txt
5
```
*(این دستور محتویات فایل را به ورودی `wc` می‌فرستد).*

---

### ۴. تغییر مسیر خطا (`2>`)
**هدف:** جدا کردن پیام‌های خطا از خروجی معمولی.
گاهی اوقات می‌خواهید خروجی برنامه را ببینید، اما خطاها را در یک فایل لاگ جداگانه ذخیره کنید (یا برعکس). عدد `2` نماینده stderr است.

**مثال:** تلاش برای پیدا کردن فایل در کل سیستم. چون دسترسی به برخی فایل‌های سیستمی نداریم، خطای "Permission denied" می‌دهد. می‌خواهیم خطاها را در `errors.log` ذخیره کنیم تا صفحه شلوغ نشود.
```bash
user@linux-machine:~$ find / -name "config.yaml" 2> errors.log
/home/user/projects/config.yaml
```
*(مسیر فایل پیدا شده در صفحه نمایش داده می‌شود، اما تمام خطاهای دسترسی به فایل `errors.log` می‌روند).*

**تکنیک حرفه‌ای (`2>&1`):**
ترکیب خطا و خروجی استاندارد در یک جا.
```bash
command > output.log 2>&1
```
*(هم خروجی و هم خطاها را در `output.log` ذخیره کن).*

---

### ۵. پایپ (`|`) - لوله‌کشی داده‌ها
**هدف:** اتصال خروجی یک دستور به ورودی دستور دیگر.
این قدرتمندترین ابزار خط فرمان است که اجازه می‌دهد دستورات ساده را زنجیروار به هم وصل کنید تا کارهای پیچیده انجام دهند.

**سینتکس:** `command1 | command2 | command3`

**مثال ۱: صفحه‌بندی خروجی طولانی**
وقتی `ls -la /etc` را می‌زنید، هزاران فایل رد می‌شوند. با پایپ کردن به `less`، می‌توانید اسکرول کنید.
```bash
user@linux-machine:~$ ls -la /etc | less
```

**مثال ۲: جستجو در پروسه‌ها (ترکیب کلاسیک)**
ترکیب `ps` و `grep` که قبلاً دیدیم.
```bash
user@linux-machine:~$ ps aux | grep firefox
```
*(خروجی `ps` به عنوان ورودی به `grep` داده می‌شود تا فیلتر شود).*

**مثال ۳: شمارش تعداد فایل‌ها**
چند فایل با فرمت `.jpg` در پوشه داریم؟
```bash
user@linux-machine:~$ ls *.jpg | wc -l
```
1.  `ls`: لیست فایل‌ها را می‌گیرد.
2.  `wc -l`: تعداد خطوط ورودی را می‌شمارد.

---

## تفاوت حیاتی: Wildcards در برابر Regex

قبل از بررسی لیست، باید بدانید کجا از کدام استفاده می‌شود:
1.  **Wildcards (Shell Globbing):** توسط خودِ **Shell (ترمینال)** تفسیر می‌شود. فقط برای تطبیق **نام فایل‌ها و پوشه‌ها** استفاده می‌شود (در دستوراتی مثل `ls`, `rm`, `cp`).
2.  **Regular Expressions (Regex):** توسط **برنامه‌ها** (مثل `grep`, `vi`, `sed`) تفسیر می‌شود. برای جستجو در **محتوای متنی** استفاده می‌شود.

---

### ۱. کاراکترهای جایگزین (Wildcards / Globbing)
*کاربرد: وقتی می‌خواهید فایل‌ها را انتخاب کنید.*

| نماد         | توضیح                                  | مثال                | نتیجه                                                 |
| :----------- | :------------------------------------- | :------------------ | :---------------------------------------------------- |
| **`*`**      | صفر یا هر تعداد کاراکتر                | `ls *.txt`          | لیست تمام فایل‌های متنی (file.txt, a.txt, .txt)       |
| **`?`**      | دقیقاً **یک** کاراکتر                  | `ls file?.txt`      | file1.txt, fileA.txt (اما file10.txt را شامل نمی‌شود) |
| **`[...]`**  | یک کاراکتر از مجموعه داخل براکت        | `ls file[123].txt`  | فقط file1.txt, file2.txt, file3.txt                   |
| **`[0-9]`**  | یک عدد در بازه مشخص شده                | `ls file[0-5].png`  | فایل‌هایی که عدد ۰ تا ۵ دارند.                        |
| **`[^...]`** | **نبودن** کاراکترهای داخل براکت (نقیض) | `rm file[^0-9].txt` | فایل‌هایی که نامشان عدد **نیست** را پاک کن.           |

---

### ۲. عبارات باقاعده (Regular Expressions - Regex)
*کاربرد: وقتی می‌خواهید درون فایل‌ها متن جستجو کنید (`grep`, `less`, `vim`).*
*نکته: برای استفاده از نمادهای پیشرفته مثل `+`, `?`, `|`, `()` در دستور `grep`، باید از `grep -E` یا `egrep` استفاده کنید.*

#### الف) لنگرها (Anchors) - موقعیت را مشخص می‌کنند
*   **`^` (Carrot):** ابتدای خط.
    *   `grep "^Error" log.txt` $\leftarrow$ خط‌هایی که دقیقاً با کلمه Error شروع می‌شوند.
*   **`$` (Dollar):** انتهای خط.
    *   `grep "end$" log.txt` $\leftarrow$ خط‌هایی که دقیقاً با کلمه end تمام می‌شوند.
*   **`^$`**: خطوط خالی (شروع و پایان بلافاصله پشت سر هم).

#### ب) تطبیق کاراکتر
*   **`.` (نقطه):** نماینده **هر** کاراکتری (فقط یکی).
    *   `gr.y` $\leftarrow$ کلمات gray, grey, gr/y, gr2y را پیدا می‌کند.
*   **`[...]` و `[^...]`:** مشابه Wildcard عمل می‌کند (محدوده کاراکتر).
    *   `[c-f]` $\leftarrow$ حروف c, d, e, یا f.

#### ج) تکرارگرها (Quantifiers) - روی کاراکتر **قبل از خود** اثر می‌گذارند
*اینجا جایی است که با Wildcard متفاوت است!*

*   **`*` (Star):** کاراکتر قبلی **۰ یا بیشتر** بار تکرار شود.
    *   `colou*r` $\leftarrow$ کلمات color, colour, colouuur را پیدا می‌کند. (u می‌تواند نباشد یا زیاد باشد).
*   **`?` (Question):** کاراکتر قبلی **۰ یا ۱** بار تکرار شود (اختیاری بودن).
    *   `colou?r` $\leftarrow$ فقط color و colour.
*   **`+` (Plus):** کاراکتر قبلی **۱ یا بیشتر** بار تکرار شود (حداقل یک بار باید باشد).
    *   `go+gle` $\leftarrow$ کلمات gogle, google, gooogle (اما ggle را پیدا نمی‌کند).
*   **`{n}`:** دقیقاً n بار تکرار.
    *   `o{3}` $\leftarrow$ کلمه ooo.
*   **`{n,m}`:** حداقل n و حداکثر m بار تکرار.

#### د) گروه‌بندی و منطق
*   **`|` (Pipe):** عملگر "یا" منطقی (OR).
    *   `grep -E "Linux|Unix" file.txt` $\leftarrow$ خطوطی که کلمه Linux **یا** Unix دارند.
*   **`()`:** گروه‌بندی برای اعمال تکرارگرها روی یک کلمه کامل.
    *   `grep -E "(ha)+"` $\leftarrow$ کلمات haha, hahaha, hahahaha را پیدا می‌کند.

---

### جدول مقایسه سریع (برای رفع ابهام دانشجو)

| علامت | در Wildcard (دستور `ls`) | در Regex (دستور `grep`) |
| :--- | :--- | :--- |
| **`*`** | همه چیز (All files) | تکرار کاراکتر قبلی (Repeat previous) |
| **`?`** | یک کاراکتر ناشناس | کاراکتر قبلی اختیاری است (0 یا 1 بار) |
| **`.`** | معنای خاصی ندارد (فقط نقطه) | هر کاراکتری (Any char) |

---
